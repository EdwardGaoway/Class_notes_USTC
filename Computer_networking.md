# CS_networking_notes 
## Chapter 1
连通性——计算机网络使上网用户之间都可以交换信息，好像这些用户的计算机都可以彼此直接连通一样。 共享——即资源共享。可以是信息共享、软件共享，也可以是硬件共享。 
路由（route, path）：分组从发送终端到接收终端经过的通信链路及分组交换机的序列。
Internet Service Provider（ISP）：由分组交换机和通信链路组成的网络为终端提供接入因特网的服务

因特网标准：以RFC（Request for comments）文档的形式发布由IETF（ Internet Engineering Task Force）组织统一管理

因特网提供的通信服务包括：源主机到目的主机的可靠数据交付,尽力而为的（不可靠的）数据交付

因特网是为分布式应用提供通信服务的基础设施：应用程序运行在端系统上,端系统为应用程序提供使用因特网服务的API

协议定义了通信实体之间交换的报文的格式和次序，以及在报文发送、接收或收到其它事件后采取的动作。掌握计算机网络知识的过程，就是理解网络协议构成、原理和工作的过程。
### A closer look at network structure
access networks：将终端连接到其边缘路由器的物理链路
network core: 路由器和通信链路组成的网状网络. 企业（和家庭）接入 广域无线接入：3G/4G

在一条路径上，每对设备之间的物理媒体可以不同导引型媒体: 信号沿固体媒体传播，如铜线，光纤/   非导引型媒体: 信号在空间自由传播，如无线电. 

网络核心: 由路由器和通信链路形成的网状网络    任务：将数据从发送终端的边缘路由器传输到接收终端的边缘路由器
基本问题: 数据如何在网络中传递?电路交换    通信前预留好端-端资源（对比：分组交换不预留资源）资源独占：保证性能（带宽，延迟）在通信的静默期，资源被闲置  频分复用FDM ，时分复用TDM
分组交换   主机将应用报文划分成分组/在从源终端到目的终端的路径上，分组从一个设备发送到下一个设备交换机仅在接收到整个分组后，才可以开始转发（存储-转发）
分组交换 packet switching    适合突发数据/简单，不需建立电路/可能产生严重拥塞: 延迟，丢包/需要有保证可靠传输和拥塞控制的协议/分组交换允许更多用户使用网络    电路交换（固定分配）分组交换（按需分配）

Q: 存储转发引入延迟 假设分组长度为L比特，链路速率为R b/s
将一个分组全部推送到一条链路上，耗时 L/R 秒
将一个分组从源发送到目的，总耗时 = 2 L/R （不考虑信号传播时间）*问题：P个分组经过N条链路的总耗时是多少？（P+N-1）L/R*

排队和丢包: (排队延时和分组丢失)/当分组到达速率大于链路输出速率时:分组在对应链路的输出缓存中排队，等待被发送到链路上，产生排队延迟 /若链路的输出缓存满，分组被丢弃，产生丢包

分组交换网络原理总结: 存储转发/动态路由(包括每个分组自带源地址、目的地址，拓扑发现、路由选择)/出错交由端系统处理

端系统通过一个接入ISP与因特网相连/接入ISP必须相互连接 /受经济因素和国家政策的影响，因特网的结构非常复杂

分组延迟的来源  节点处理: 检查比特错误/确定输出链路  /排队在输出缓存等待传输 /时间长短取决于链路拥塞程度
传输延迟:R=link bandwidth (bps)/L=packet length (bits)
将分组发送到链路上的时间 = L/R
传播延迟:d = length of physical link/s = propagation speed in medium (~2x108 m/sec/propagation delay = d/s
输出队列的容量是有限的/队列满时，新到达的分组被丢弃/在端到端的路径上，限制了端到端吞吐量的通信链路。

分层：将系统功能组织成一系列水平的层次，每层实现一个功能（服务）/每层通过以下方式提供它的服务：/在本层内执行一些动作/依靠下层提供的服务/易于处理复杂系统:/显式的层次结构易于确定系统的各个部分及其相互关系
/模块化简化了系统的维护和升级/改变某层服务的实现对于其它层次是透明的
application: 支持各种网络应用E.g., FTP, SMTP, HTTP
transport: 进程-进程的分组传输TCP, UDP
network: 源主机-目的主机的分组传输
IP, routing protocols
link: 相邻网络设备之间的分组传输E.g., PPP, Ethernet
physical: 在物理媒体上传输比特

## chapter2 应用层
编写分布式程序，使得可以
运行在不同的端系统上
通过网络相互通信
例如，web服务器软件与浏览器软件
不需为网络核心设备写程序
网络核心设备不运行用户应用
在端系统上开发应用有利于应用的快速研发和部署

客户-服务器架构
服务器: 
一台总是在线的主机，运行着服务器程序
具有永久IP地址
使用主机集群或数据中心提高处理能力
客户机:
需要时与服务器通信 
可能间断地连在网络上
通常使用动态IP地址
不与其它客户机直接通信
P2P架构
没有总是运行的服务器
任意一对端系统（对等方）间可以直接通信
对等方间断连接，并使用动态IP地址
每个对等方可以请求服务，也可以提供服务

在同一个主机中，两个进程使用进程间通信机制（由OS定义）进行通信.
不同主机上的进程通过交换报文进行通信
客户进程: 发起通信的进程
服务器进程: 等待联系的进程  Note: P2P架构的应用同时具有客户进程和服务器进程
进程通过套接字（socket）发送和接收报文
套接字类似于一扇门：
发送进程将报文推出门
门外的运输设施（因特网）将报文送到接收进程的门口
套接字是应用层和传输层的接口，也是应用程序和网络之间的API
为了接收报文，每个进程必须有标识

主机使用IP地址进行标识
Q: 用进程所在主机的IP地址能否标识进程？
A: 不能，因为同一个主机上可能运行着许多进程。
端口号被用来区分同一个主机上的不同进程。
进程标识包括：
IP地址
与该进程关联的端口号
TCP service:
面向连接: 客户进程和服务器进程需要建立连接
发送进程和接收进程之间可靠传输
流量控制: 发送进程不会“压垮”接收进程 
拥塞控制: 网络超载时抑制发送进程
不提供: 及时性，最低带宽保证
UDP service:
发送进程和接收进程之间不可靠传输 
不提供: 连接建立，可靠传输，流量控制，拥塞控制，及时性，最低带宽保证 

应用层协议定义了：
交换的报文类型, 
e.g., request, response 
报文语法:
报文中的字段及其描述
报文语义 
各字段中信息的含义
进程何时及如何发送/响应报文的规则
Web采用客户-服务器模式
client: 浏览器请求、接收和显示web对象
server: Web服务器应客户请求发送对象
使用TCP作为传输层协议:
客户发起到服务器 80 端口的 TCP 连接（客户端创建一个套接字）
服务器接受来自客户的TCP连接（服务器端创建一个套接字）
浏览器和服务器交换HTTP报文 （通过各自的套接字）
关闭TCP 连接    HTTP是“无状态的”
服务器不保存有关客户请求的任何信息

非持久 HTTP
在一个TCP连接上最多发送一个对象。
HTTP/1.0 使用非持久连接。
持久 HTTP
在一个TCP连接上可以发送多个对象。
HTTP/1.1 缺省使用持久连接。
RTT (Round-Trip Time): 一个小分组从客户发送到服务器再返回客户的时间。
Response time:
建立TCP连接用时一个RTT
发送HTTP请求至收到响应的前几个字节用时一个RTT
传输文件的时间

下载一个对象的时间 = 2RTT+对象传输时间
下载完整网页的时间 = 22RTT(11个对象)
非持久HTTP 的问题:
获取每个对象需要2个RTT
每个TCP连接需要消耗操作系统资源
浏览器通常打开多个TCP连接获取引用对象，消耗资源

持久 HTTP
服务器在发送响应后保持连接
同一对客户-服务器之间的后续HTTP报文可以在该连接上传输
无流水线方式:
客户仅当收到前一个响应后再发送新的请求
请求每个对象用时1个RTT
请求一个网页用时12RTT
两类HTTP报文: 请求报文，响应报文
HTTP报文由ASCII文本构成
流水线方式:
HTTP/1.1缺省使用该方式
客户每解析到一个引用对象就可以发送请求
可在一个RTT时间内请求所有引用对象
请求一个网页用时约3RTT
HTTP请求报文
状态行，首部行，数据，如请求的HTML文件

``` 
200 OK
request succeeded, requested object later in this message
301 Moved Permanently
requested object moved, new location specified later in this message (Location:)
400 Bad Request
request message not understood by server
404 Not Found
requested document not found on this server
505 HTTP Version Not Supported
```

cookie
Four components:
1) HTTP响应报文中的cookie首部行
2) HTTP请求报文中的cookie 首部行
3) 保存在用户主机的cookie文件，由用户的浏览器管理
4) Web网站的后端数据库

服务器端：信息保存在服务器端，返回一个ID给客户
客户端：信息发回客户端，保存在cookie文件中，并随请求报文发送给服务器

 Web缓存（代理服务器）浏览器将HTTP请求发送给web缓存：
对象在web缓存中: web缓存返回对象 
对象不在web缓存中：web缓存从原始服务器获取对象，缓存在本地，然后返回给客户
Web cache既是服务器又是客户机  Why Web caching?
减少客户请求的响应时间
减少机构接入链路上的流量

caching example:  Assumptions
平均对象长度 = 1Mb
从机构浏览器到原始服务器的平均请求速率 = 15/sec
从接入路由器到原始服务器的来回延迟（RTT）= 2 sec

FTP文件传输协议  用户通过FTP用户代理，从远程主机下载文件或向远程主机上传文件
FTP采用客户-服务器模式
客户：启动传输的一方
使用TCP协议
ftp server:  使用端口21、20
控制连接：
使用端口21，传送客户命令和服务器响应。
控制连接在整个会话期间一直保持。

数据连接：
使用端口20，传输文件
每个数据连接只传输一个文件，发送方用关闭连接表示一个文件传输结束。
Q：为什么将控制连接与数据连接分开？
A：不会混淆数据与命令/响应，简化协议设计和实现
     在传输文件的过程中可以继续执行其它的操作
     便于控制传输过程（如客户可以随时终止传输）

Q：为什么用关闭数据连接的方式结束文件传输？
A：允许动态创建文件（不需预先告知文件的大小）

电子邮件：
三个主要组成部分: 
用户代理 将要外发的邮件发送到用户的邮件服务器
从用户邮箱中取邮件

邮件服务器邮件服务器上包含：
用户信箱：存放到来的邮件
发送报文队列：存放要发送出去的邮件
报文传输代理MTA：运行在服务器后台的系统守护进程，负责在邮件服务器之间传输邮件，及将收到的邮件放入用户信箱。
电子邮件地址：
由两个部分组成，形如：mailbox@computer
前者为标识用户信箱的字符串，后者为信箱所在的邮件服务器的名字。

简单邮件传输协议SMTP邮件服务器之间传输邮件采用客户-服务器模式：
客户: 发送邮件的服务器
服务器: 接收邮件的服务器
SMTP使用TCP作为传输层协议，服务器端口为25
发送服务器和接收服务器之间直接传输邮件
SMTP采用命令/响应交互方式：
命令: ASCII文本
响应: 状态码和短语
报文只能包含简单ASCII文本（7位ASCII码）
Alice的邮件服务器与Bob的邮件服务器建立TCP连接，然后发送 Alice的邮件
5) Bob的邮件服务器将邮件放置在Bob的信箱中
6) Bob调用他的用户代理阅读邮件

邮件传送阶段（1）
连接与握手：
MTA客户与MTA服务器在端口25建立TCP连接。
服务器发送服务就绪报文
客户发送HELO报文，用域名标识自己
服务器响应
(3)
结束传输
客户发送QUIT报文
服务器响应
释放TCP连接

SMTP使用持久连接：
可以在一条TCP连接上传输多个报文
一个方向的报文传输结束后，可以在另一个方向上传输报文

SMTP 服务器使用“.”表示报文结束（FTP使用关闭连接表示传输结束，HTTP使用长度域表示报文结束）

SMTP要求报文（报头和实体）只包含简单ASCII文本（HTTP无此要求）
报头由一些首部行组成，如：
To:
From:
Subject:
实体: 只能使用简单ASCII字符
Q：能将用户信箱放在本地终端吗？
A：不能，用户终端不可能一直连在因特网上

Q：能用SMTP从邮件服务器中获取邮件吗？
A：不能，SMTP是一个“推”协议，只能将邮件从用户代理推送到其邮件服务器。

解决方案：设计一个新的协议从服务器获取邮件



